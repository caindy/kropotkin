#!/usr/bin/python

from json import dumps, loads
from os import fork, mkfifo, rename, setsid
from os import close as osclose, open as osopen
from os import read as osread, write as oswrite
from os import O_RDONLY, O_WRONLY
from os.path import join
from socket import getfqdn, socket, AF_INET, SOCK_STREAM
from SocketServer import BaseRequestHandler, ForkingMixIn, TCPServer
from sys import argv, exit, stderr, stdin, stdout
from tempfile import mkdtemp
from time import time

def create_queue(message_size=512):
    stderr.write("Creating queue with message size %d\n" % message_size)
    queue_dir = mkdtemp(prefix='boringq.')
    auxiliary_queue_file = join(queue_dir, 'auxiliary.json')
    with open(auxiliary_queue_file, 'w') as f:
        f.write(dumps({}))
    pid = fork()
    if pid == 0: # Child
        setsid()
        _run_server(queue_dir, message_size)
    else: # Parent
        identifier_file = join(queue_dir, 'identifier.json')
        finish = int(time()) + 5
        while int(time()) < finish:
            try:
                with open(identifier_file, 'r') as f:
                    return f.read()
            except IOError:
                pass
        stderr.write('Timed out waiting for socket server.')
        return False

def enqueue(identifier, message):
    stderr.write("enqueue %s on queue %s\n" % (message, identifier))
    q_info = loads(identifier)
    host = q_info['host']
    port = q_info['port']
    message_size = q_info['message_size']
    if len(message) > message_size:
        stderr.write('Message larger than max size %d' % message_size)
        return False
    message = message.ljust(message_size, '\x00')

    sock = socket(AF_INET, SOCK_STREAM)
    try:
        sock.connect((host, port))
        sock.sendall(message)
    finally:
        sock.close()
    return True

def dequeue(identifier):
    stderr.write("dequeue from %s\n" % identifier)
    q_info = loads(identifier)
    queue_dir = q_info['queue_dir']
    auxiliary_queue_file = join(queue_dir, 'auxiliary.json')
    with open(auxiliary_queue_file, 'r') as f:
        auxiliary_queue = loads(f.read())
    if len(auxiliary_queue) != 0:
        message = auxiliary_queue.pop(0)
        with open(auxiliary_queue_file, 'w') as f:
            f.write(dumps(auxiliary_queue))
        return message

    pipe = join(queue_dir, 'boringq_pipe')
    message_size = q_info['message_size']

    fd = None
    messages = []
    try:
        fd = osopen(pipe, O_RDONLY)

        while True:
            message = osread(fd, message_size)
            if len(message) == 0:
                break
            else:
                print "Received message %s\n" % message.rstrip('\x00')
                messages.append(message.rstrip('\x00'))

    finally:
        if fd:
            osclose(fd)
    message = messages.pop(0)
    with open(auxiliary_queue_file, 'w') as f:
        f.write(dumps(messages))
    return message

def main(argv):
    if (len(argv) <= 1):
        stderr.write('Must supply an action as first argument\n')
        return False
    action = argv[1]
    if action == 'create_queue':
        if (len(argv) >= 3):
            output = create_queue(int(argv[2]))
        else:
            output = create_queue()
        if output:
            stdout.write(output)
            return True
        else:
            return False
    elif action == 'enqueue' and len(argv) >= 3:
        message = stdin.read()
        return enqueue(argv[2], message)
    elif action == 'dequeue' and len(argv) >= 3:
        output = dequeue(argv[2])
        if output:
            stdout.write(output)
            return True
        else:
            return False
    else:
        stderr.write("action %s not recognised or wrong params\n" % action)
        return False

def _run_server(queue_dir, message_size):
    host = getfqdn()
    pipe = join(queue_dir, 'boringq_pipe')
    mkfifo(pipe)
    server = QueueServer((host, 0), QueueRequestHandler)
    server.message_size = message_size
    server.pipe = pipe
    ip, port = server.server_address
    identifier = {'host': host,
                  'port': port,
                  'queue_dir': queue_dir,
                  'message_size': message_size}

    temp_identifier_file = join(queue_dir, 'identifier.json.temp')
    identifier_file      = join(queue_dir, 'identifier.json')
    with open(temp_identifier_file, 'w') as f:
        f.write(dumps(identifier))
    rename(temp_identifier_file, identifier_file)

    server.serve_forever()

class QueueRequestHandler(BaseRequestHandler):
    def handle(self):
        message = self.request.recv(self.server.message_size)
        fd = None
        try:
            fd = osopen(self.server.pipe, O_WRONLY)
            oswrite(fd, message)
        finally:
            if fd:
                osclose(fd)

class QueueServer(ForkingMixIn, TCPServer):
    pass

if main(argv):
    exit(0)
else:
    exit(1)
